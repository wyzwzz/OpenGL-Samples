# 光追结果降噪
## 空间滤波降噪
考虑一个像素周围区域 比如7x7的区域 计算该区域内每一个像素的贡献（中心像素的权重为1）
周围像素的权重计算可以考虑多个指标 比如其到中心像素之间的距离（像素代表的世界坐标的距离） 
像素之间颜色的差异 像素之间法向量的差异（比如两个夹角为90度的面）
两个像素是否处于同一个平面（放在桌子上的书） 权重是各个指标综合计算的结果 每个指标之间也许是存在矛盾关系的
比如同一平面但刚好是同一物体 所以每个指标还要除以相对应的各自的权重后最后得到 该像素对中心像素的贡献权重
最后中心像素的颜色就是区域内颜色的累加和除以权重和
## 时间滤波降噪
上一帧的信息不能直接拿来使用 我们需要的是这一帧所绘制的物体可以在上一帧找到位置才将其对应的像素颜色拿来使用
所以要记录每一帧绘制时每个物体对应的model矩阵 以及view projection矩阵（为下一帧时间滤波服务）
对这一帧的物体 通过model矩阵的逆矩阵可以得到 world pos （因为每一帧的world pos 都是顶点坐标通过model矩阵变换得到的）
这也就是说 模型的运动应该只体现在model矩阵上 如果是真的模型本身顶点坐标发生了变化 那么就不适用了
然后再乘以上一帧的mvp矩阵得到像素坐标 也就是说 通过一些列操作
我们得到了当前帧像素对应的物体在上一帧对应的像素坐标 当然坐标可能是非法的 那么就标志invalid 如果合法 那么标志valid 接下来会使用到
我们还希望这一帧与上一帧之间的颜色差距不要过大 也就是说 上一帧作为历史累积帧 并不是valid就可以直接使用 因为这一帧可能突然变了光照材质之类的
所以我们首先要计算这一帧每一个像素周边7x7领域的均值μ和方差σ 然后把上一帧的对应像素的颜色clamp在(μ-kσ,μ+kσ)范围内
至此完成所有滤波操作 然后把这一帧最后的结果存储为最新的累积帧
如果是第一帧的话 只进行空间滤波然后保存结果 不需要时间滤波